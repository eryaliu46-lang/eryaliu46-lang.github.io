<html lang="en">  
<head>  
    <meta charset="UTF-8">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <title>Merry Christmas - Grand Digital Tree</title>  
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">  
    <style>  
        :root { --gold: #d4af37; --cream: #fceea7; --bg: #000000; }  
        body { margin: 0; padding: 0; background-color: var(--bg); color: var(--gold); font-family: 'Times New Roman', serif; overflow: hidden; user-select: none; }  
          
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; transition: opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1); }  
        #ui-layer.ui-hidden { opacity: 0; }  
          
        .header { position: absolute; top: 5%; left: 50%; transform: translateX(-50%); text-align: center; }  
        h1 { font-family: 'Cinzel', serif; font-size: 56px; margin: 0; background: linear-gradient(to bottom, #ffffff, var(--gold)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 15px rgba(212, 175, 55, 0.5)); letter-spacing: 4px; }  
          
        .upload-wrapper { position: absolute; bottom: 8%; left: 50%; transform: translateX(-50%); text-align: center; pointer-events: auto; }  
        .btn-upload { padding: 12px 30px; background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(15px); border: 1px solid var(--gold); color: var(--gold); font-family: 'Cinzel', serif; font-size: 14px; cursor: pointer; letter-spacing: 2px; transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }  
        .btn-upload:hover { background: var(--gold); color: black; box-shadow: 0 0 30px var(--gold); transform: scale(1.05); }  
        .hint { margin-top: 15px; font-size: 11px; opacity: 0.6; text-transform: uppercase; letter-spacing: 1px; }  
  
        #loader { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; transition: opacity 1.5s; }  
        .spinner { width: 50px; height: 50px; border: 1px solid transparent; border-top: 1px solid var(--gold); border-radius: 50%; animation: spin 1s cubic-bezier(0.42, 0, 0.58, 1) infinite; }  
        @keyframes spin { to { transform: rotate(360deg); } }  
        .loader-text { margin-top: 25px; font-family: 'Cinzel', serif; letter-spacing: 4px; font-size: 12px; color: var(--gold); }  
  
        #video-container { position: fixed; bottom: 20px; right: 20px; width: 160px; height: 120px; opacity: 0; pointer-events: none; }  
    </style>  
</head>  
<body>  
  
<div id="loader">  
    <div class="spinner"></div>  
    <div class="loader-text">WAKING UP THE MAGIC</div>  
</div>  
  
<div id="ui-layer">  
    <div class="header"><h1>Merry Christmas</h1></div>  
    <div class="upload-wrapper">  
        <button class="btn-upload" onclick="document.getElementById('file-input').click()">ADD MEMORIES</button>  
        <input type="file" id="file-input" style="display:none" multiple accept="image/*">  
        <div class="hint">Press 'H' to Hide Controls</div>  
    </div>  
</div>  
  
<div id="video-container"><video id="webcam-video" autoplay playsinline></video></div>  
  
<script type="importmap">  
{  
    "imports": {  
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",  
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",  
        "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"  
    }  
}  
</script>  
  
<script type="module">  
import * as THREE from 'three';  
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';  
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';  
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';  
import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';  
import { HandLandmarker, FilesetResolver } from "@mediapipe/tasks-vision";  
  
const STATE = {  
    mode: 'TREE',  
    targetPhoto: null,  
    lerpFactor: 0.08,  
    mainGroupRotation: new THREE.Euler(),  
    photoPool: [],  
    isUiVisible: true,  
    time: 0  
};  
  
/**  
 * CONFIG: 宏大尺寸设置  
 * 显著扩大树体高度(38)和底座半径(18)  
 */  
const CONFIG = {  
    treeParticleCount: 1600,  
    dustCount: 2600,  
    treeHeight: 38.0,   
    treeBaseRadius: 18.0,   
    colors: { gold: 0xd4af37, red: 0xbc131f, green: 0x1a472a }  
};  
  
class ChristmasApp {  
    constructor() {  
        this.initScene();  
        this.initPostProcessing();  
        this.initEnvironment();  
        this.createContent();  
        this.initVision();  
        this.setupEvents();  
        this.animate();  
    }  
  
    initScene() {  
        this.scene = new THREE.Scene();  
        this.mainGroup = new THREE.Group();  
        this.scene.add(this.mainGroup);  
  
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);  
        this.camera.position.set(0, 2, 52); // 相机略微靠近以增加宏伟感  
  
        this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });  
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));  
        this.renderer.setSize(window.innerWidth, window.innerHeight);  
        this.renderer.toneMapping = THREE.ReinhardToneMapping;  
        this.renderer.toneMappingExposure = 2.4;  
        document.body.appendChild(this.renderer.domElement);  
  
        this.scene.add(new THREE.AmbientLight(0xffffff, 0.8));  
          
        const spotGold = new THREE.SpotLight(0xffd700, 2200);  
        spotGold.position.set(30, 80, 50);  
        this.scene.add(spotGold);  
  
        const spotBlue = new THREE.SpotLight(0x44aaff, 1500);  
        spotBlue.position.set(-50, 20, -30);  
        this.scene.add(spotBlue);  
    }  
  
    initPostProcessing() {  
        this.composer = new EffectComposer(this.renderer);  
        this.composer.addPass(new RenderPass(this.scene, this.camera));  
        this.composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.5, 0.4, 0.85));  
    }  
  
    initEnvironment() {  
        const pmrem = new THREE.PMREMGenerator(this.renderer);  
        this.scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;  
    }  
  
    createContent() {  
        this.particles = [];  
        const goldMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 0.95, roughness: 0.05 });  
        const redMat = new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.red, clearcoat: 1.0, metalness: 0.5 });  
        const greenMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.green, roughness: 0.8 });  
  
        // 1. 圣诞星 (悬浮在宏大顶端)  
        this.createStarTop(goldMat);  
  
        // 2. 核心粒子  
        for (let i = 0; i < CONFIG.treeParticleCount; i++) {  
            const rand = Math.random();  
            let geom = rand < 0.5 ? new THREE.BoxGeometry(0.55, 0.55, 0.55) : new THREE.SphereGeometry(0.35, 12, 12);  
            let mat = rand < 0.4 ? goldMat : (rand < 0.7 ? redMat : greenMat);  
            const mesh = new THREE.Mesh(geom, mat);  
            this.setupParticleData(mesh, i, CONFIG.treeParticleCount, 'MAIN');  
            this.mainGroup.add(mesh);  
            this.particles.push(mesh);  
        }  
  
        // 3. 环境尘埃  
        const dustMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });  
        for (let i = 0; i < CONFIG.dustCount; i++) {  
            const dust = new THREE.Mesh(new THREE.SphereGeometry(0.09, 6, 6), dustMat);  
            this.setupParticleData(dust, i, CONFIG.dustCount, 'DUST');  
            this.mainGroup.add(dust);  
            this.particles.push(dust);  
        }  
  
        this.createDefaultPhoto();  
    }  
  
    createStarTop(material) {  
        const shape = new THREE.Shape();  
        const outerRadius = 2.4;   
        const innerRadius = 0.95;  
        for (let i = 0; i < 10; i++) {  
            const r = i % 2 === 0 ? outerRadius : innerRadius;  
            const a = (i * Math.PI) / 5;  
            if (i === 0) shape.moveTo(Math.cos(a) * r, Math.sin(a) * r);  
            else shape.lineTo(Math.cos(a) * r, Math.sin(a) * r);  
        }  
        shape.closePath();  
  
        const starGeom = new THREE.ExtrudeGeometry(shape, { depth: 0.5, bevelEnabled: true, bevelThickness: 0.2, bevelSize: 0.2 });  
        const star = new THREE.Mesh(starGeom, material);  
        star.userData.type = 'STAR';  
        // 随树体高度动态调整位置  
        star.userData.treePos = new THREE.Vector3(0, (CONFIG.treeHeight / 2) + 2.5, 0);  
        star.userData.scatterPos = new THREE.Vector3(0, 25, 0);  
        star.userData.rotVel = new THREE.Vector3(0.02, 0.05, 0.01);  
        this.mainGroup.add(star);  
        this.particles.push(star);  
    }  
  
    setupParticleData(obj, index, total, type) {  
        obj.userData.type = type;  
        const t = index / total;  
        // 螺旋算法密度优化  
        const angle = t * Math.PI * 48;  
        const radius = CONFIG.treeBaseRadius * (1 - t);  
        const y = t * CONFIG.treeHeight - (CONFIG.treeHeight / 2);  
          
        obj.userData.treePos = new THREE.Vector3(  
            Math.cos(angle) * (radius + (type === 'DUST' ? (Math.random()-0.5)*1.5 : 0)),  
            y + (Math.random()-0.5)*0.8,  
            Math.sin(angle) * (radius + (type === 'DUST' ? (Math.random()-0.5)*1.5 : 0))  
        );  
  
        obj.userData.scatterPos = new THREE.Vector3().setFromSphericalCoords(  
            15 + Math.random() * 20,  
            Math.random() * Math.PI,  
            Math.random() * Math.PI * 2  
        );  
  
        obj.userData.rotVel = new THREE.Vector3(Math.random() * 0.04, Math.random() * 0.04, Math.random() * 0.04);  
        obj.position.copy(obj.userData.scatterPos);  
    }  
  
    createDefaultPhoto() {  
        const canvas = document.createElement('canvas');  
        canvas.width = 1024; canvas.height = 1024;  
        const ctx = canvas.getContext('2d');  
        ctx.fillStyle = '#111'; ctx.fillRect(0,0,1024,1024);  
        ctx.strokeStyle = '#d4af37'; ctx.lineWidth = 40; ctx.strokeRect(20,20,984,984);  
        ctx.fillStyle = '#fceea7'; ctx.font = 'bold 120px Cinzel'; ctx.textAlign = 'center';  
        ctx.fillText('JOYEUX', 512, 480); ctx.fillText('NOEL', 512, 640);  
          
        const texture = new THREE.CanvasTexture(canvas);  
        texture.anisotropy = this.renderer.capabilities.getMaxAnisotropy();  
        this.addPhotoToScene(texture);  
    }  
  
    addPhotoToScene(texture) {  
        const group = new THREE.Group();  
        texture.colorSpace = THREE.SRGBColorSpace;  
        texture.anisotropy = this.renderer.capabilities.getMaxAnisotropy();  
          
        const photo = new THREE.Mesh(  
            new THREE.PlaneGeometry(4, 4),   
            new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide })  
        );  
          
        const frame = new THREE.Mesh(  
            new THREE.BoxGeometry(4.2, 4.2, 0.1),   
            new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: 0.8, roughness: 0.2 })  
        );  
        frame.position.z = -0.15; // 消除 Z-fighting  
          
        group.add(photo, frame);  
        this.setupParticleData(group, STATE.photoPool.length, 10, 'PHOTO');  
        this.mainGroup.add(group);  
        this.particles.push(group);  
        STATE.photoPool.push(group);  
    }  
  
    async initVision() {  
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");  
        this.handLandmarker = await HandLandmarker.createFromOptions(vision, {  
            baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },  
            runningMode: "VIDEO", numHands: 1  
        });  
        const video = document.getElementById('webcam-video');  
        navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {  
            video.srcObject = stream;  
            video.onloadeddata = () => {  
                document.getElementById('loader').style.opacity = '0';  
                setTimeout(() => document.getElementById('loader').remove(), 1000);  
            };  
        });  
    }  
  
    setupEvents() {  
        window.addEventListener('resize', () => {  
            this.camera.aspect = window.innerWidth / window.innerHeight;  
            this.camera.updateProjectionMatrix();  
            this.renderer.setSize(window.innerWidth, window.innerHeight);  
            this.composer.setSize(window.innerWidth, window.innerHeight);  
        });  
        window.addEventListener('keydown', (e) => {  
            if (e.key.toLowerCase() === 'h') {  
                STATE.isUiVisible = !STATE.isUiVisible;  
                document.getElementById('ui-layer').className = STATE.isUiVisible ? '' : 'ui-hidden';  
            }  
        });  
        document.getElementById('file-input').onchange = (e) => {  
            Array.from(e.target.files).forEach(f => {  
                const reader = new FileReader();  
                reader.onload = (ev) => {  
                    new THREE.TextureLoader().load(ev.target.result, (t) => {  
                        t.colorSpace = THREE.SRGBColorSpace;  
                        t.anisotropy = this.renderer.capabilities.getMaxAnisotropy();  
                        this.addPhotoToScene(t);  
                    });  
                };  
                reader.readAsDataURL(f);  
            });  
        };  
    }  
  
    animate() {  
        requestAnimationFrame(() => this.animate());  
        STATE.time += 0.01;  
  
        const video = document.getElementById('webcam-video');  
        if (video.readyState >= 2) {  
            const results = this.handLandmarker.detectForVideo(video, performance.now());  
            if (results.landmarks && results.landmarks.length > 0) {  
                const hand = results.landmarks[0];  
                const distPinch = Math.hypot(hand[4].x - hand[8].x, hand[4].y - hand[8].y);  
                const avgDist = [8,12,16,20].reduce((a,b) => a + Math.hypot(hand[b].x-hand[0].x, hand[b].y-hand[0].y), 0) / 4;  
  
                if (distPinch < 0.045) {  
                    if (STATE.mode !== 'FOCUS') {  
                        STATE.mode = 'FOCUS';  
                        STATE.targetPhoto = STATE.photoPool[Math.floor(Math.random()*STATE.photoPool.length)];  
                    }  
                } else if (avgDist < 0.22) STATE.mode = 'TREE';  
                else if (avgDist > 0.45) STATE.mode = 'SCATTER';  
  
                STATE.mainGroupRotation.y = (hand[9].x - 0.5) * 1.8;  
                STATE.mainGroupRotation.x = (hand[9].y - 0.5) * 1.2;  
            }  
        }  
  
        // 旋转平滑化  
        this.mainGroup.rotation.x = THREE.MathUtils.lerp(this.mainGroup.rotation.x, STATE.mainGroupRotation.x, 0.1);  
        this.mainGroup.rotation.y = THREE.MathUtils.lerp(this.mainGroup.rotation.y, STATE.mainGroupRotation.y, 0.1);  
  
        this.particles.forEach((p, i) => {  
            let targetPos = new THREE.Vector3();  
            let targetScale = 1;  
            let isFocused = false;  
  
            if (STATE.mode === 'TREE') {  
                targetPos.copy(p.userData.treePos);  
                if (p.userData.type === 'DUST') {  
                    targetPos.x += Math.sin(STATE.time * 2 + i) * 0.25;  
                    targetPos.z += Math.cos(STATE.time * 2 + i) * 0.25;  
                }  
                if (p.userData.type === 'STAR') {  
                    p.rotation.y += 0.045;   
                    p.rotation.z = Math.sin(STATE.time) * 0.12;  
                } else {  
                    p.rotation.y += 0.01;  
                }  
            } else if (STATE.mode === 'SCATTER') {  
                targetPos.copy(p.userData.scatterPos);  
                p.rotation.x += p.userData.rotVel.x;  
                p.rotation.y += p.userData.rotVel.y;  
                p.rotation.z += p.userData.rotVel.z;  
            } else if (STATE.mode === 'FOCUS') {  
                if (p === STATE.targetPhoto) {  
                    targetPos.set(0, 2, 42); // 进一步拉近到相机前  
                    targetScale = 4.8;  
                    isFocused = true;  
                } else {  
                    targetPos.copy(p.userData.scatterPos).multiplyScalar(2.2);  
                    p.rotation.x += p.userData.rotVel.x * 0.5;  
                }  
            }  
  
            p.position.lerp(targetPos, STATE.lerpFactor);  
            const s = THREE.MathUtils.lerp(p.scale.x, targetScale, STATE.lerpFactor);  
            p.scale.set(s, s, s);  
  
            if (isFocused) {  
                p.rotation.set(0, 0, 0); // 聚焦时锁定旋转，保证清晰度  
            }  
        });  
  
        this.composer.render();  
    }  
}  
  
new ChristmasApp();  
</script>  
</body>  
</html>  